@@include('abi.html')

<script>
  const privateKey =
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80";

  let contract_address, token_address;
  let provider, signer, walletAddress;
  let contract, token_contract;
  contract_address = "0x5FbDB2315678afecb367f032d93F642f64180aa3";

  const initApp = async () => {
    provider = new ethers.getDefaultProvider("http://127.0.0.1:8545/");
    signer = await provider.getSigner();
    contract = new ethers.Contract(contract_address, super_abi, signer);

    token_address = await contract.token();
    token_contract = new ethers.Contract(token_address, token_abi, signer);

    walletAddress = await signer.getAddress();
  };
  initApp()

  const initForwardApp = async () => {
    if (window.parent.ethereum == null) {
      console.log("MetaMask not installed; using read-only defaults");
      provider = new ethers.JsonRpcProvider()
    } else {
      provider = new ethers.BrowserProvider(window.parent.ethereum);
    }
    signer = await provider.getSigner();
    contract = new ethers.Contract(contract_address, super_abi, signer);

    token_address = await contract.token();
    token_contract = new ethers.Contract(token_address, token_abi, signer);

    walletAddress = await signer.getAddress();
  }

  async function checkConnection() {
    try {
      // Проверка провайдера
      await provider.getNetwork();

      // Проверка signer (кошелька)
      const address = await signer.getAddress();
      if (!address) throw new Error("Wallet address not available");

      console.log("All connections are available");
    } catch (error) {
      console.error("Connection check failed:", error.message);
      if (
        confirm(
          "A contract or wallet is not available. Do you want to reinitialize the application?",
        )
      ) {
        await initApp(); // comment before upload to forward
        // await initForwardApp(); // only for forward
      }
    }
  }

  async function fetchPosts() {
    const posts = [];
    let data;

    try {
      // Check if mini_contract is initialized
      if (!mini_contract) throw new Error("Mini contract not initialized");

      data = await mini_contract.queryFilter("ProposalCreated");
    } catch (error) {
      console.error("Error fetching posts:", error);
      // Retry after a delay if initialization error
      await new Promise((resolve) => setTimeout(resolve, 3000));
      return fetchPosts();
    }

    for (const [index, item] of data.entries()) {
      let formattedDate;
      const block = await provider.getBlock(item.args.voteStart);
      if (block) {
        const date = new Date(block.timestamp * 1000);
        const day = date.getDate();
        const month = date.getMonth() + 1;
        const year = date.getFullYear();
        formattedDate = `${day < 10 ? "0" : ""}${day}.${
          month < 10 ? "0" : ""
        }${month}.${year}`;
      }

      const status_id = await mini_contract.state(item.args.proposalId);
      const votes = await mini_contract.proposalVotes(item.args.proposalId);
      const decimals = await token_contract.decimals();
      const cp = Number(votes[1] / 10n ** decimals);
      const cn = Number(votes[2] / 10n ** decimals);
      const cd = Number(votes[0] / 10n ** decimals);
      const summ = cp + cn + cd;
      const countUp = formatNumber(cp);
      const countNeutral = formatNumber(cn);
      const countDown = formatNumber(cd);

      const token_name = await token_contract.name();

      const title = await mini_contract.titles(item.args.proposalId);
      const post = {
        index: index,
        title: title,
        proposer: item.args.proposer,
        vote_start: block ? formattedDate : item.args.voteStart,
        time: getVotingEndText(item.args.voteEnd),
        description: item.args.description,
        status: getStatusNameById(status_id),
        status_id: status_id,
        votes: {
          down: {
            text: `${countDown.toString()} ${token_name}`,
            percent: summ === 0 ? 0 : (cd / summ) * 100,
          },
          up: {
            text: `${countUp.toString()} ${token_name}`,
            percent: summ === 0 ? 0 : (cp / summ) * 100,
          },
          neutral: {
            text: `${countNeutral.toString()} ${token_name}`,
            percent: summ === 0 ? 0 : (cn / summ) * 100,
          },
        },
        extra: {
          targets: Object.values(item.args.targets),
          values:
            Object.values(item.args.values).length < 1
              ? Array(Object.values(item.args.targets).length).fill(0)
              : Object.values(item.args.values),
          calldatas: Object.values(item.args.calldatas),
          proposalId: item.args.proposalId,
        },
      };

      posts.push(post);
    }

    return posts.reverse();
  }
</script>